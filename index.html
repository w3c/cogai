<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Chunks and Rules</title>
  <script async class="remove" src="https://www.w3.org/Tools/respec/respec-w3c"></script>
  <script class="remove">
    var respecConfig = {
      shortName: "chunks",
      specStatus: "CG-DRAFT",
      noRecTrack: true,
      edDraftURI: "https://w3c.github.io/cogai/",
      editors:  [
        {
          name: "Fran√ßois Daoust",
          company: "W3C",
          companyURL: "https://www.w3.org/",
          w3cid: "41989"
        },
        {
          name: "Dave Raggett",
          company: "W3C",
          companyURL: "https://www.w3.org/",
          w3cid: "2682"
        }
      ],
      group: "cogai",
      github: {
        repoURL: "https://github.com/w3c/cogai/",
        branch: "master"
      },
      localBiblio: {
        "CHUNKS-INTRO": {
          title: "Introduction to chunks and rules",
          href: "https://www.w3.org/Data/demos/chunks/chunks.html",
          authors: [
            "Dave Raggett"
          ]
        },
        "IEEE-754-2019": {
          title: "IEEE 754-2019: IEEE Standard for Floating-Point Arithmetic. Institute of Electrical and Electronic Engineers, New York (2019)"
        }
      }
    };
  </script>
  <style>
    .railroad {
      margin-top: 1em;
      margin-bottom: 2em;
    }
  </style>
</head>
<body>
  <section id="abstract">
    <p>This specification defines a cognitive database model based on graphs, rules that operate on them in conjunction with highly scalable graph algorithms, suitable for handling big data, and a format to serialize graphs. The model is designed with the aim of facilitating machine learning for vocabularies and rules, and inspired by advances in the cognitive sciences on the organisation of the mammalian brain.</p>
  </section>

  <section id="sotd">
    <p>This document is at early stages of development. Feedback is welcome through <a href="https://github.com/w3c/cogai/issues">GitHub issues</a> or on the <a href="mailto:public-cogai@w3.org">public-cogai@w3.org</a> mailing-list (with <a href="https://lists.w3.org/Archives/Public/public-cogai/">public archives</a>).</p>
  </section>

  <section class="informative">
    <h2>Introduction</h2>
    <p>This specification defines a cognitive database model based on graphs and rules that operate on them, modeled after the organisation of the mammalian brain, as described by cognitive sciences, with the aim of facilitating machine learning processing of big data.</p>

    <figure id="cog-arch">
      <img src="demos/chunks/arch.png" alt="" />
      <figcaption>Architecture of the cognitive database model</figcaption>
    </figure>

    <p>At its heart, the model is based on [=graphs of chunks=] composed of a collection of [=chunks=], where each [=chunk=] represents a collection of basic familiar units that have been grouped together and stored in memory. To ease manipulation of procedural knowledge as declarative knowledge, [=chunks=] are used to model both declarative knowledge (i.e. data) as well as procedural knowledge (i.e. rules). See [[CHUNKS-INTRO]] for details.</p>

    <p>The [=rule engine=] operates on a set of [=modules=], where each [=module=] has a [=graph of chunks=] and supports a <a data-lt="built-in operations">common set of operations</a> on chunks. Each module also has a single [=module buffer=] that the [=rule engine=] can process and that can hold one and only one [=chunk=] at a time.</p>

    <p>This specification also defines a <a href="#chunks-documents">serialization format</a> for graphs of chunks, used in examples throughout this specification.</p>
  </section>

  <section id="conformance">
    <p>The grammatical rules in this document are to be interpreted as described in [[[RFC5234]]] [[RFC5234]].</p>
    <section>
      <h3>Conformance classes</h3>
      <p>Conformance to this specification is defined for four conformance classes:</p>
      <dl>
        <dt><dfn>Chunks document</dfn></dt>
        <dd>A serialization of a [=graph of chunks=] as a file. A [=chunks document=] is conformant to this specification if it follows the grammar described in <a href="#chunks-grammar"></a>.</dd>
        <dt><dfn>Authoring tool</dfn></dt>
        <dd>An application that writes a [=chunks document=]. An [=authoring tool=] is conformant to this specification if it writes conforming [=chunks documents=].</dd>
        <dt><dfn>Parser</dfn></dt>
        <dd>A [=parser=] transforms a [=chunks document=] into another representation. A [=parser=] is conformant to this specification if it accepts any conforming [=chunks document=].</dd>
        <dt><dfn>Rule engine</dfn></dt>
        <dd>A processing application that operates on graphs of chunks and rules, organized following the cognitive agent architecture described in this specification. A [=rule engine=] is conformant to this specification if it follows the algorithms defined in <a href="#rule-engine-execution"></a>.</dd>
      </dl>
    </section>
  </section>

  <section>
    <h2>Data types</h2>
    <p>This document uses the following restricted set of data types to describe [=chunks=]. See <a href="#chunks-grammar"></a> for a formal definition of their serialization.</p>

    <p>A <dfn>number</dfn> represents a double-precision 64-bit format value as specified in the IEEE Standard for Binary Floating-Point Arithmeticis [[IEEE-754-2019]]. It is serialized in base 10 using decimal digits, following the same grammar as <a data-cite="RFC8259#section-6">numbers in JSON</a> [[RFC8259]].</p>

    <p>A <dfn>boolean</dfn> represents a logical entity having two values. It is serialized as either the literal name <code>true</code>, which gets interpreted as a truthy value, or the literal name <code>false</code>, which gets interpreted as a falsy value.</p>

    <p>A <dfn>date</dfn> is an [[ISO8601]] string that represents a date. A [=date=] value implicitly creates a read-only chunk whose type is <code>iso8601</code> with properties that match actual date components.</p>

    <aside class="example" title="Date example">
      <p>Here is an example of a chunk that describes Albert Einstein's birth date:</p>
<pre><code>person Albert_Einstein {
  birthdate 1879-03-14
}</code></pre>
      <p>This chunk implicitly creates the following chunk definition:</p>
<pre><code>iso8601 1879-03-14 {
  year 1879
  month 3
  day 14
}
</code></pre>
    </aside>

    <p class="issue">Clarify that only a subset of ISO8601 is supported (see <a href="https://github.com/w3c/cogai/issues/8">issue #8</a>).</p>

    <p class="issue">To prepend <code>iso8601</code> and related properties with <code>@</code> or not to prepend with <code>@</code>, that is the question (see <a href="https://github.com/w3c/cogai/issues/2">issue #2</a>).</p>

    <p>A <dfn>string literal</dfn> is an arbitrary set of characters. It is serialized enclosed in double quotes, following the same grammar as <a data-cite="RFC8259#section-7">strings in JSON</a> [[RFC8259]].</p>

    <p>A <dfn>name</dfn> is a string that can include letters, digits, period, hyphen, underscore and slash characters, and that cannot be interpreted as a [=number=], a [=boolean=]. Additionally, depending on the context under which it is used, a [=name=] may start with one of the [[[#name-operators]]].</p>

    <p>A property [=value=] |a| <dfn>equals</dfn> property [=value=] |b| when the following algorithm returns <code>true</code>:</p>
    <ul>
      <li>If |a| is the [=wild card operator=] <code>*</code>, return <code>true</code>.</li>
      <li>If |b| is the [=wild card operator=] <code>*</code>, return <code>true</code>.</li>
      <li>If |a| is the [=negation operator=] <code>!</code>, return <code>false</code>.</li>
      <li>If |b| is the [=negation operator=] <code>!</code>, return <code>false</code>.</li>
      <li>If |a| is a [=name=] that starts with the [=negation operator=] <code>!</code>, return <code>false</code> if !|a| [=equals=] |b|, <code>true</code> otherwise.</li>
      <li>If |b| is a [=name=] that starts with the [=negation operator=] <code>!</code>, return <code>false</code> if |a| [=equals=] !|b|, <code>true</code> otherwise.</li>
      <li>If |a| is a [=variable=] that is not yet [=bound=] to a value, return <code>true</code>.</li>
      <li>If |b| is a [=variable=] that is not yet [=bound=] to a value, return <code>true</code>.</li>
      <li>If |a| is a [=variable=] [=bound=] to a value |v|, return <code>true</code> if |v| [=equals=] |b|, <code>false</code> otherwise.</li>
      <li>If |b| is a [=variable=] [=bound=] to a value |v|, return <code>true</code> if |a| [=equals=] |v|, <code>false</code> otherwise.</li>
      <li>If |a| and |b| are identical [=atomic values=], return <code>true</code>.</li>
      <li>If |a] and |b| are lists of [=atomic values=], both lists have the same length, and [=atomic values=] at the same position in |a| and |b| are [=equal=], return <code>true</code>.</li>
      <li>Otherwise, return <code>false</code>.</li>
    </ul>
  </section>
</section>

  <section>
    <h2>Chunks and graphs</h2>
    <p>A <dfn>chunk</dfn> is a named typed collection of [=properties=]. A [=chunk=] is used to model both declarative knowledge and procedural knowledge as a collection of basic familiar units that have been grouped together and stored in memory.</p>
    <p>A [=chunk=] has a [=type=] and an optional [=identifier=].</p>

    <aside class="note" title="Serialization of a chunk">
      <p>When serialized in a [=chunks document=], the declaration of a [=chunk=] always starts with a chunk [=type=], followed by an optional chunk [=identifier=], and a set of [=properties=] enclosed in braces (<code>{}</code>). Lists are represented as comma separated values. Whitespaces may appear anywhere between constructs. See <a href="#chunks-grammar"></a> for details.</p>
    </aside>
    <aside class="example" title="A chunk to describe a dog">
<pre><code>dog dog1 {
  name "Fido"
  age 4
}</code></pre>
      <p>This [=chunk=] describes a dog named "Fido" that is 4 years old. The chunk [=type=] is <code>dog</code>. Its [=identifier=] is <code>dog1</code> and uniquely identifies this chunk within the graph it is defined in. The chunk has two [=properties=]:</p>
      <ul>
        <li><code>name</code> whose value is the [=string literal=] <code>"Fido"</code></li>
        <li><code>age</code> whose value is the [=number=] <code>4</code></li>
      </ul>
    </aside>

    <section>
      <h3>Chunk type</h3>
      <p>A chunk <dfn>type</dfn> is a [=name=] that documents the nature of a chunk. The [=type=] is used to group and index chunks. [=Rules=] typically apply to chunks of a given [=type=].</p>
      <aside class="example" title="A chunk of type &quot;person&quot;">
<pre><code>person Dave {
  knows Francois
}</code></pre>
      </aside>
      <p>As a special case, the [=type=] may be formed by a single asterisk (<code>*</code>), which is used to describe a [=condition=] or [=action=] that matches any chunk [=type=].</p>
    </section>

    <section>
      <h3>Chunk identifier</h3>
      <p>The chunk <dfn>identifier</dfn> is a [=name=] that uniquely identifies a chunk within the graph it is defined in.</p>
      <p>The chunk [=identifier=] is optional.</p>
    </section>

    <section>
      <h3>Chunk properties</h3>
      <p>A chunk <dfn>property</dfn> is a [=name=]/[=value=] pair that describes a chunk across the particular dimension identified by the property name.</p>

      <p>A <dfn>value</dfn> is either an [=atomic value=] or an ordered list of [=atomic values=] (values are comma-separated in serialized form).</p>

      <p>An <dfn>atomic value</dfn> is either:</p>
      <ul>
        <li>a [=name=], which can for instance be used to reference other chunks</li>
        <li>a [=number=]</li>
        <li>a [=boolean=] (<code>true</code> or <code>false</code>)</li>
        <li>a [=date=]</li>
        <li>a [=string literal=]</li>
      </ul>
    </section>

    <section>
      <h3>Chunk context</h3>
      <p>A [=chunk=] may be scoped to a <dfn>context</dfn>, which identifies the specific situation under which the [=chunk=] should be considered to be true. This mechanism allows [=chunks=] to describe things that are only true in hypothetical situations.</p>

      <p>[=Contexts=] can be used to express situations that involve the use of statements about statements, including beliefs, stories, reported speech, examples in lessons, abductive reasoning and even search query patterns. They are also useful for episodic memory when one wants to describe facts that are true in a given situation, for instance an even when a peson visited a restaurant for lunch, sat by the window, and had soup for starters followed by mushroom risotto for the main course. A sequence of episodes can then be modelled as relationships between contexts.</p>

      <p>A [=chunk=] gets associated with a specific [=context=] through an [=@context=] [=property=].</p>

      <p>A [=chunk=] that is not explicitly associated with a [=context=] (i.e. in the absence of an [=@context=] property) belongs to the <dfn>default context</dfn>.</p>

      <aside class="example" title="Expressing a belief">
        <p>Here is an example from John Sowa's <a href="http://www.jfsowa.com/pubs/arch.htm">Architectures for Intelligent Systems</a>:</p>
        <p><cite>Tom believes that Mary wants to marry a sailor.</cite></p>
        <p>This example involves talking about a statement <cite>Mary wants to marry a sailor</cite> that is only known to be true according to Tom's belief. When represented as [=chunks=], the statement needs to be associated with a [=context=] that identifies Tom's belief, so that we cannot directly assert that the statement is true in general.</p>
        <p>Similarly, the statement <cite>to marry a sailor</cite> is only known to be true according to Mary's desire. When represented as [=chunks=], the statement also needs to be associated with a [=context=] that identifies Mary's desire.</p>

        <p>Here is one possible way to represent the overall statement with [=chunks=]:</p>
        <pre><code>believes {
  @subject tom
  proposition tom-belief-1
}
wants {
  @context tom-belief-1
  @subject mary
  situation mary-desire-1
}
married-to {
  @context mary-desire-1
  @subject mary
  @object s1
}
a s1 {
  @context mary-desire-1
  profession sailor
}</code></pre>
      </aside>

      <p>As illustrated in the previous example, [=contexts=] can be chained, e.g. to describe the beliefs of someone in a fictional story or movie, and to indicate when a context is part of several other contexts, thus creating a tree of [=contexts=].</p>

      <p>Practically speaking, [=contexts=] make it possible to filter out non relevant [=chunks=] in [=conditions=] and [=actions=]. Two [=chunks=] may only [=match=] when they belong to the same context. For instance, a [=chunk=] that belongs to the context <code>tom-belief-1</code> can only [=match=] [=chunks=] that also belong to that context, and de facto cannot match [=chunks=] that belong to the [=default context=]. In particular, a [=chunk=] that belongs to the [=default context=] can only [=match=] [=chunks=] that also belong to the [=default context=].</p>
    </section>

    <section>
      <h3>Links between chunks</h3>
      <p>In this document, a <dfn>link</dfn> is a directed and labeled connection between two [=chunks=]. A [=link=] is automatically created whenever a chunk property [=value=] is a [=name=] that references an existing chunk [=identifier=].</p>
      <p>The <dfn>subject</dfn> of the [=link=] identifies the [=chunk=] at the origin of the connection. The <dfn>object</dfn> of the [=link=] identifies the [=chunk=] targeted by the connection. The <dfn>label</dfn> of the [=link=] is the property [=name=].</p>
      <aside class="example" title="A link between two chunks">
<pre><code>friend f34 {
  name Joan
}
friend f35 {
  name Jenny
  likes f34
}</code></pre>
        <p>The above definition creates a link between <code>f35</code> and <code>f34</code> with the relationship <code>likes</code>.</p>
      </aside>

      <p>When a [=chunk=] links to another [=chunk=], this implicitly creates a third [=chunk=] whose [=type=] is the name of the [=property=] that creates the [=link=], and that has two [=properties=]:</p>
      <ul>
        <li><dfn><code>@subject</code></dfn>: references the [=subject=] of a [=link=]</li>
        <li><dfn><code>@object</code></dfn>: references the [=object=] of a [=link=]</li>
      </ul>

      <aside class="example" title="Links as chunks">
<pre><code>animal dog {
  kindof mammal
}</code></pre>

<p>The previous definition implicitly creates the following [=chunk=]:</p>

<pre><code>kindof {
  @subject dog
  @object mammal
}</code></pre>
      </aside>

      <aside class="note" title="Compact format for links">
        <p>The <a href="#chunks-grammar">grammar</a> allows to express [=links=] in a compact format in a [=chunks document=], e.g.:</p>
<pre><code>dog kindof mammal
cat kindof mammal</code></pre>
        <p>This is equivalent to:</p>
        <pre><code>kindof {
  @subject dog
  @object mammal
}
kindof {
  @subject cat
  @object mammal
}</code></pre>
      </aside>
    </section>

    <section>
      <h3>Graph of chunks</h3>
      <p>A <dfn data-lt="graphs of chunks">graph of chunks</dfn> is simply a collection of [=chunks=]. The vertices of the graph are the [=chunks=]. The edges of the graph are the [=links=] between the chunks.</p>
      <p>Since [=links=] are directed, a [=graph of chunks=] is a directed graph.</p>
    </section>
  </section>

  <section>
    <h2>Rules and modules</h2>
    <section>
      <h3>Rules</h3>
      <p>A <dfn>rule</dfn> is a [=chunk=] whose [=type=] is <code>rule</code> and that has:</p>
      <ul>
        <li>an <dfn><code>@condition</code></dfn> [=property=], whose value is a chunk [=identifier=] or a list thereof, and which is used to reference the rule's [=conditions=].</li>
        <li>an <dfn><code>@action</code></dfn> [=property=], whose value is a chunk [=identifier=] or a list thereof, and which is used to reference the rule's [=actions=].</li>
      </ul>

      <p>A [=rule=] represents a unit of procedural knowledge. Rules consist of [=conditions=] and [=actions=].</p>

      <aside class="example" title="Basic rule definition">
        <p>The following [=rule=] has one [=condition=] (that holds true when the <code>goal</code> [=module buffer=] contains a [=chunk=] whose [=type=] is <code>remember</code>), and two [=actions=] that clears the <code>goal</code> [=module buffer=] and that loads a [=chunk=] whose type is <code>memory</code> in the <code>facts</code> [=module=]:</p>
        <pre><code>rule r1 {
  @condition c1
  @action a1, a2
}

remember c1 {}
next a1 { @do clear }
memory a2 { @module facts }</code></pre>
      </aside>

      <aside class="note" title="Compact format for rules">
        <p>The <a href="#chunks-grammar">grammar</a> allows to express [=rules=] in a compact format in a [=chunks document=]. For instance, the previous example may be written as:</p>
<pre><code>remember {}
  => next { @do clear },
     memory { @module facts }</code></pre>
        <p>This compact format makes the link between [=conditions=] and [=actions=] more explicit and avoids the need to provide chunk [=identifiers=].</p>
      </aside>

      <section>
        <h4>Conditions</h4>
        <p>A <dfn>condition</dfn> is a [=chunk=] that describes the premises that must hold true for a [=rule=] to apply. A [=condition=] identifies which [=module=] it relates to through an [=@module=] property, defaulting to the <code>goal</code> module. A [=condition=] holds true when the [=chunk=] in the related [=module buffer=] is a [=matching chunk=] for the [=condition=].</p>
      </section>

      <section>
        <h4>Actions</h4>
        <p>An <dfn>action</dfn> is a [=chunk=] that can directly update [=module buffers=], or can do so indirectly, e.g. by sending messages to the [=module=] to invoke graph algorithms, such as graph queries and updates, or to carry out operations, e.g. instructing a robot to move its arm. When the algorithm or operation is complete, a response can be sent back to update the module's buffer. This in turn can trigger further rules as needed.</p>
        <p>In many cases, the actual operation that an [=action=] will carry out will appear as an [=@do=] property. Built-in operations are always supported (see <a href="#built-in-operations"></a>). Additional actions may be supported.</p>
      </section>

      <section>
        <h4>Matching chunks</h4>

        <p>A [=chunk=] |A| <dfn data-lt="matching chunk">matches</dfn> [=chunk=] |B| if the conditions below are all met:</p>
        <ul>
          <li><i>Context</i>. One of the following conditions holds true:
            <ul>
              <li>Neither |A| nor |B| have [=@context=] properties.</li>
              <li>Both |A| and |B| have [=@context=] properties and |A|'s [=@context=] property [=value=] [=equals=] |B|'s [=@context=] property [=value=].</li>
            </ul>
          </li>
          <li><i>Identifier</i>. One of the following conditions holds true:
            <ul>
              <li>|A| has an [=@id=] property whose [=value=] is an [=atomic value=] that [=equals=] |B|'s [=identifier=].</li>
              <li>|A| does not have an [=@id=] property.</li>
            </ul>
          </li>
          <li><i>Inheritance</i>. One of the following conditions holds true:
            <ul>
              <li>|A| has an [=@kindof=] property whose [=value=] |V| is an [=atomic value=], and |B|'s [=type=] is a subclass of |V|, meaning that |B|'s [=type=] is |V| or there exists a chain of <code>kindof</code> links between |V| and |B|'s [=type=].</li>
              <li>|A| does not have an [=@kindof=] property.</li>
            </ul>
          </li>
          <li><i>Properties</i>. For each [=property=] |p| in |A| whose [=name=] does not start with <code>@</code>, either of the following holds true:
            <ul>
              <li>|p|'s [=value=] is <code>!</code> and there is no [=property=] in |B| with |p|'s [=name=].</li>
              <li>|p|'s [=value=] is not <code>!</code> and there exits a [=property=] in |B| with the same [=name=] and [=equal=] [=value=] as |p|.</li>
            </ul>
          </li>
          <li><i>Type</i>. One of the following conditions holds true:
            <ul>
              <li>|A| has an [=@type=] property whose [=value=] is an [=atomic value=] that [=equals=] |B|'s [=type=].</li>
              <li>|A| does not have an [=@type=] property, and |A|'s [=type=] is <code>*</code>.</li>
              <li>|A| does not have an [=@type=] property, and |A|'s [=type=] and |B|'s [=type=] are identical.</li>
            </ul>
          </li>
        </ul>
      </section>
    </section>

    <section>
      <h3>Modules</h3>
      <p>A <dfn>module</dfn> is a [=graph of chunks=] associated with one and only one [=module buffer=]. A [=module=] has a <dfn>module name</dfn> that follows the [=name=] data type, and that is typically used to target the [=module=] in [=@module=] properties.</p>

      <p>A [=module=] supports [=built-in operations=], and may support additional operations defined by the application when the [=module=] is initialized.</p>
      <p>A [=module=] represents a cognitive database on which the [=rule engine=] may operate. It may be viewed as a region in the cerebral cortex, where the [=module buffer=] corresponds to the bundle of nerve fibres connecting to that region.</p>

      <p>The [=rule engine=] automatically creates a module named <code>goal</code>, which will therefore always exist in a rule execution context.</p>

      <p>The [=@module=] property allows [=conditions=] and [=actions=] to reference the [=module name=] of the [=module=] they relate to. In the absence of an [=@module=] property, [=conditions=] and [=actions=] apply to the <code>goal</code> module.</p>

      <section>
        <h4>Module buffers</h4>
        <p>A <dfn>module buffer</dfn> is a container for at most one [=chunk=]. The mammalian brain is richly connected locally, and weakly remotely. A [=module buffer=] mimics the constrained communication capacity of the mammalian brains for such long range communication.</p>

        <p>The [=rule engine=] operates on a module's [=graph of chunks=] through its [=module buffer=].</p>

        <p>A [=module buffer=] has a <dfn data-dfn-for="module buffer">status</dfn>, whose value is initially [=status/okay=], and which reflects the outcome of the last [=action=] held and performed by the [=module buffer=]. Values can be:</p>
        <dl>
          <dt><dfn><code>pending</code></dfn></dt>
          <dd>The operation is still pending.</dd>
          <dt><dfn><code>okay</code></dfn></dt>
          <dd>The operation completed successfully.</dd>
          <dd><p class="issue">Switch to <code>ok</code>? This seems more common in technologies (e.g. HTTP) than <code>okay</code>.</p></dd>
          <dt><dfn><code>forbidden</code></dfn></dt>
          <dd>The operation was not allowed.</dd>
          <dt><dfn><code>nomatch</code></dfn></dt>
          <dd>The operation failed because there was no [=matching chunk=] for the [=action=] in the targeted [=module=].</dd>
          <dt><dfn><code>failed</code></dfn></dt>
          <dd>The operation failed.</dd>
        </dl>

        <p>A [=module buffer=] has a <dfn>queue</dfn>, which is a set of [=chunks=], initially empty. Each chunk in the [=queue=] has a <dfn>priority</dfn>, represented by an integer from 1 to 10, with 10 the highest priority. The default [=priority=] is 5. [=Chunks=] are ordered by descending [=priority=] in a [=queue=]. When [=priorities=] match, [=chunks=] are ordered by insertion order (first in, first out).</p>

        <p>The <dfn><code>@priority</code></dfn> property lets [=actions=] set the [=priority=] of a [=chunk=] when they add it to a [=queue=].</p>

        <aside class="note" title="Queue and sub-goals">
          <p>A [=queue=] may be useful to create sub-goals. For instance, whilst [=@do update=] operations allow applications to switch to a new goal, they may prefer [=rules=] to propose multiple sub-goals instead. [=Queues=] enable this through [=@do queue=] operations which push the [=chunk=] specified by an [=action=] to the [=queue=] of a [=module buffer=].</p>
        </aside>

        <p>A [=module buffer=] is automatically cleared when the [=actions=] associated with the [=rule=] it contained did not update the contents of targeted [=module buffers=]. This pops the [=queue=] if it is not already empty.</p>
      </section>

      <section>
        <h4>Built-in operations</h4>
        <p>The [=@do=] property lets an [=action=] specify the graph algorithm or operation to execute. The default operation is to update the [=module buffer=], similar to calling [=@do update=].</p>

        <p>All [=modules=] support the <dfn>built-in operations</dfn> defined in this section.</p>

        <p>All [=modules=] also support the [=@for=] property to iterate over a set of items in a comma separated list. This has the effect of loading the [=module buffer=] with the first item in the list. The index range can optionally be specified with [=@from=] and [=@to=], where the first item in the list has index <code>0</code>.</p>

        <aside class="note" title="Application-defined operations">
          <p>Applications can define additional operations when initialising a [=module=]. This can be used to perform a variety of operations, e.g. to allow rules to command a robot to move its arm, by passing it the desired position and direction of the robot's hand. Operations can be defined to allow messages to be spoken aloud or to support complex graph algorithms, e.g. for data analytics and machine learning.</p>

          <p>Applications cannot replace the [=built-in operations=].</p>
        </aside>

        <section>
          <h5>The <dfn><code>@do clear</code></dfn> operation</h5>
          <p>Clears the [=module buffer=] and pops the [=queue=].</p>
        </section>

        <section>
          <h5>The <dfn><code>@do delete</code></dfn> operation</h5>
          <p>Forgets [=matching chunks=] in the [=graph of chunks=].</p>
        </section>

        <section>
          <h5>The <dfn><code>@do get</code></dfn> operation</h5>
          <p>Looks for a [=matching chunk=] in the module's [=graph of chunks=] and puts a copy of it in the [=module buffer=] if found. Modifying the [=properties=] of a [=chunk=] copied from a [=graph of chunks=] (e.g. through a [=@do update=] operation) will not alter the underlying [=graph of chunks=]. To save an updated [=chunk=], a [=@do put=] or [=@do patch=] command needs to be issued.</p>
        </section>

        <section>
          <h5>The <dfn><code>@do next</code></dfn> operation</h5>
          <p>Loads the next [=matching chunk=] to the targeted [=module buffer=] in an implementation dependent order.</p>
        </section>

        <section>
          <h5>The <dfn><code>@do patch</code></dfn> operation</h5>
          <p>If the [=chunk=] in the targeted [=module buffer=] has the same [=identifier=] as a [=chunk=] in the underlying [=graph of chunks=], patches the [=chunk=] in the [=graph of chunks=] with the [=properties=] that appear in the [=module buffer=], excluding [=properties=] prefixed with an <code>@</code> character.</p>
          <p class="issue">What is the expected behavior when the action has an <code>@id</code> property?</p>
        </section>

        <section>
          <h5>The <dfn><code>@do properties</code></dfn> operation</h5>
          <p>Initiates an iteration over the [=properties=] of the [=matching chunk=] that do not begin with <code>@</code>. Each [=property=] is mapped to a new [=chunk=] with the same [=type=] as the [=action=]. The action's properties are copied over, and <code>name</code> and <code>value</code> properties are used to pass the [=property=] name and value respectively. The [=@more=] property is given the value <code>true</code> unless this is the final [=chunk=] in the iteration, in which case [=@more=] is given the value false. By default, the iteration is written to the same [=module buffer=] as designated by the [=action=] that initiated it. However, you can designate a different [=module buffer=] with the [=@to=] property. By setting additional properties in the initiating action, you can ensure that the rules used to process the property name and value are distinct from other such iterations.</p>
          <aside class="example" title="Iterate over properties">
            <p>The following example first sets the <code>facts</code> [=module buffer=] to a [=chunk=] of [=type=] <code>foo</code>, and then initiates an iteration over all of the [=chunk=]'s properties:</p>
            <pre><code>run {}
  =>
    foo {@module facts; a 1; c 2}, # set facts buffer to foo {a 1; c 2}
    bar {@module facts; @do properties; loop prop18; @to goal} # launch iteration

# this rule is invoked with the name and value for each property
# note that 'loop prop18' is copied over from the initiating chunk
# (also note that "@do log" is an hypothetical operation to log a message)
bar {loop prop18; name ?name; value ?value}
  =>
    console {@do log; message ?name, is, ?value},
    bar {@do next}  # to load the next instance from the iteration</code></pre>
          </aside>
        </section>

        <section>
          <h5>The <dfn><code>@do put</code></dfn> operation</h5>
          <p>Saves the contents of the [=module buffer=] as a [=chunk=] to the module's [=graph of chunks=]. If the [=action=] has an [=@id=] property, this operation will overwrite the [=chunk=] with the same [=identifier=] or will create a new [=chunk=] with the given [=identifier=] if it does not exist already. This operation will also create a new [=chunk=] in the absence of an [=@id=] property.</p>
          <p class="issue">If a chunk was loaded with <code>@do get</code>, then updated with <code>@do update</code>, would a call to <code>@do patch</code> create a new chunk if <code>@id</code> is not set? Or would it rather update the chunk in the graph?</p>
        </section>

        <section>
          <h5>The <dfn><code>@do queue</code></dfn> operation</h5>
          <p>Pushes a [=chunk=] to the [=queue=] for the [=module buffer=]. If a [=@priority=] property is set to an integer value between 1 and 10, the [=priority=] of the [=chunk=] in the [=queue=] is set to that value.</p>
        </section>

        <section>
          <h5>The <dfn><code>@do update</code></dfn> operation</h5>
          <p>Directly updates the [=module buffer=] if the chunk [=type=] for the [=action=] is the same as the [=chunk=] currently held in the [=module buffer=]. The operation updates the properties given in the [=action=], leaving aside properties prefixed with an <code>@</code> character, and leaving other existing properties unchanged. If the chunk [=type=] for the action is not the same as the [=chunk=] currently held in the [=module buffer=], a new [=chunk=] is created with the properties given in the [=action=], excluding properties prefixed with an <code>@</code> character. This is the default action when an [=action=] has neither an [=@do=] property nor an [=@for=] property.</p>
          <p class="issue">How can one update the properties prefixed with an <code>@</code> character in a [=chunk=] such as [=@context=], [=@subject=] or [=@object=]?</p>
        </section>
      </section>
    </section>
  </section>

  <section>
    <h2>Name operators</h2>
    <p>Operators defined in this section may be used on their own as [=names=] or in front of [=names=] to alter their meaning.</p>

    <section>
      <h3>The variable operator <code>?</code></h3>

      <p>The <dfn>variable operator</dfn> <code>?</code> may be prepended to a [=name=] when used as a [=property=] value to turn the [=name=] into a <dfn>variable</dfn> which represents a symbolic name to a [=value=]. A [=variable=] gets <dfn>bound</dfn> to a [=value=] in a [=condition=]. The [=value=] can then be referenced in [=actions=] using the [=variable=]'s name. Effectively, [=variables=] allow applications to copy information from rule [=conditions=] to rule [=actions=].</p>

      <p>[=Variables=] are scoped to the [=rule=] where they appear.</p>

      <aside class="example" title="Variable binding and referencing">
        <pre><code>count { state start; from ?num1; to ?num2 }
=> increment { @module facts; @do get; number ?num1 }</code></pre>
        <p>The above [=rule=] defines a [=condition=] that [=matches=] a [=chunk=] in the <code>goal</code> [=module buffer=] whose [=type=] is <code>count</code>, that has a <code>state</code> [=property=] whose value is <code>start</code>, and that has <code>from</code> and <code>to</code> [=properties=]. The [=condition=] binds the value of the [=variable=] <code>?num1</code> to the [=value=] of the <code>from</code> [=property=] in the matching chunk, and the value of the [=variable=] <code>?num2</code> to the [=value=] of the <code>to</code> [=property=].</p>
        <p>The [=rule=] defines an [=action=] that looks for a [=chunk=] in the <code>facts</code> [=module=] whose [=type=] is <code>increment</code> and that has a [=property=] named <code>number</code> and whose [=value=] equals the value of the <code>?num1</code> [=variable=].</p>
      </aside>

      <p>[=Variables=] are [=bound=] to a [=value=] the first time they appear in a [=condition=]. Subsequent occurrences of the same [=variable=] in a [=condition=] reference their [=value=].</p>

      <aside class="example" title="Variable binding and referencing in the same condition">
        <pre><code>count { state start; from ?num1; to ?num1 }
=> console { @do log; message ?num1 }</code></pre>
        <p>The above [=rule=] defines a [=condition=] that [=matches=] a [=chunk=] in the <code>goal</code> [=module buffer=] whose [=type=] is <code>count</code>, that has a <code>state</code> [=property=] whose value is <code>start</code>, and that has <code>from</code> and <code>to</code> [=properties=] that have identical values. The [=condition=] binds the value of the [=variable=] <code>?num1</code> to the [=value=] of the <code>from</code> [=property=] in the matching chunk.</p>
      </aside>

      <p>[=Variables=] may represent any type of [=value=]. In particular, a [=variable=] that [=matches=] a property whose value is a list of [=atomic values=] gets bound to the list of [=atomic values=].</p>

      <aside class="example" title="Variable binding to a list of atomic values">
        <pre><code>basket { fruit ?f }
=> console { @do log; message ?f }</code></pre>
        <p>The above [=rule=] defines a [=condition=] that [=matches=] a [=chunk=] in the <code>goal</code> [=module buffer=] whose [=type=] is <code>basket</code> and that has a <code>fruit</code> [=property=]. Given the following [=chunk=] in the <code>goal</code> [=module buffer=], the [=condition=] binds variable <code>?f</code> to <code>apple, banana, orange</code>:</p>
        <pre><code>basket { fruit apple, banana, orange }</code></pre>
      </aside>

      <p>A [=condition=] that contains a [=property=] with a list of [=variables=] [=matches=] a list of [=atomic values=] that has the same length. The [=condition=] does not [=match=] when the lengths of the lists differ.</p>

      <aside class="example" title="Variable binding to atomic values in a list">
        <pre><code>basket { fruit ?a, ?b, ?o }
=> console { @do log; message ?a, ?b, ?o }</code></pre>
        <p>The above [=rule=] defines a [=condition=] that [=matches=] a [=chunk=] in the <code>goal</code> [=module buffer=] whose [=type=] is <code>basket</code> and that has a <code>fruit</code> [=property=] whose value is a list of <em>three</em> atomic values. Given the following [=chunk=] in the <code>goal</code> [=module buffer=], the [=condition=] binds variable <code>?a</code> to <code>apple</code>, <code>?b</code> to <code>banana</code>, and <code>?o</code> to <code>orange</code>:</p>
        <pre><code>basket { fruit apple, banana, orange }</code></pre>
      </aside>
    </section>

    <section>
      <h3>The wild card operator <code>*</code></h3>
      <p>The <dfn>wild card operator</dfn> <code>*</code> may be used on its own in lieu of a [=name=] in one of the following cases:</p>
      <ul>
        <li>
          As the [=type=] of a [=condition=] or [=action=] to denote that [=condition=] or [=action=] matches a [=chunk=] regardless of its [=type=].
          <aside class="example" title="Condition that matches any chunk">
            <pre><code>* {} => ...</code></pre>
            <p>The <code>* {}</code> [=condition=] [=matches=] a [=chunk=] regardless of its [=type=] and [=properties=].</p>
          </aside>
        </li>
        <li>
          In a [=condition=] as the [=value=] of a [=property=] |p| to have the [=condition=] [=match=] a [=chunk=] that has a [=property=] whose [=name=] equals |p|'s [=name=], regardless of its [=value=].
          <aside class="example" title="Match a property regardless of its value">
            <pre><code>basket { fruit * } => ...</code></pre>
            <p>The [=condition=] [=matches=] a [=chunk=] whose [=type=] is <code>basket</code> and which has a <code>fruit</code> [=property=] .</p>
          </aside>
          <p class="note">A [=variable=] may also be used to [=match=] on any [=value=]. The [=wild card operator=] avoids the need to provide a name for the [=variable=] when the actual [=value=] does not need to be captured.</p>
        </li>
        <li>
          In a [=condition=] as an [=atomic value=] in a list to [=match=] any [=atomic value=] at the same position in a [=chunk=].
          <aside class="example" title="Match an atomic value in a list">
            <pre><code>basket { fruit apple, *, * } => ...</code></pre>
            <p>The [=condition=] [=matches=] a [=chunk=] whose [=type=] is <code>basket</code> and which has a <code>fruit</code> [=property=] whose [=value=] is a list of three [=atomic values=] starting with <code>apple</code>.</p>
          </aside>
        </li>
      </ul>
    </section>

    <section>
      <h3>The negation operator <code>!</code></h3>
      <p>The <dfn data-lt="negative operation">negation operator</dfn> <code>!</code> may be prepended to [=names=] to <dfn>negate</dfn> the outcome of their evaluation. The [=negation operator=] may be used in one of the following cases:</p>
      <ul>
        <li>
          In a [=rule=] in front of a [=condition=] to negate it. A rule with a negated [=condition=] !|cond| applies if and only if |cond| does not hold true.
          <aside class="example" title="Negate a rule condition">
            <pre><code># Rule with a negated condition
rule {
@condition !c1
@action a1
}
person c1 { @id John }
console a1 { @do log; message "Type is not person or id is not John" }

# Same rule defined using the compact format
!person { @id John }
=> console { @do log; message "Type is not person or id is not John" }</code></pre>
            <p>The above example illustrates two equivalent ways to define a rule with a negated condition. In this example, the condition |c1| [=matches=] a [=chunk=] whose [=type=] is <code>person</code> and whose [=identifier=] is <code>John</code>. As such, the negated condition [=matches=] a [=chunk=] whose [=type=] is <em>not</em> <code>person</code> <em>or</em> whose [=identifier=] is <em>not</em> <code>John</code>.</p>
          </aside>
        </li>
        <li>
          In a [=condition=] in front of a [=property=] value to negate the result of a [=match=]. A negated [=property=] value !|val1| [=equals=] another [=property=] value |val2| if and only if |val1| does not [=equal=] |val2|.
          <aside class="example" title="Negate a value match">
            <pre><code>person { @id !John }
=> console { @do log; message "Type is person but id is not John" }</code></pre>
            <p>The above [=condition=] [=matches=] a [=chunk=] whose [=type=] is <code>person</code> and whose [=identifier=] is <em>not</em> <code>John</code>.</p>
          </aside>
          <aside class="example" title="Negate an atomic value in a list">
            <pre><code>basket { fruit ?a, !banana, ?o }
=> console { @do log; message "No banana in second position" }</code></pre>
            <p>The above [=condition=] [=matches=] a [=chunk=] whose [=type=] is <code>basket</code> and which has a <code>fruit</code> [=property=] whose [=value=] is a list of three [=atomic values=]. First and third [=atomic values=] in that list can be anything. Second [=atomic value=] must <em>not</em> be <code>banana</code>.</p>
          </aside>
        </li>
        <li>
          On its own as a [=property=] value in a [=condition=] to test that a [=property=] is undefined. A [=condition=] with a [=property=] |p| whose value is <code>!</code> [=matches=] a [=chunk=] if and only if the [=chunk=] does not have a [=property=] whose [=name=] is |p|'s [=name=].
          <aside class="example" title="Test that a property is undefined">
            <pre><code>basket { fruit ! }
=> console { @do log; message "Basket without fruits" }</code></pre>
            <p>The above [=condition=] [=matches=] a [=chunk=] whose [=type=] is <code>basket</code> and which does not have a <code>fruit</code> [=property=].</p>
          </aside>
        </li>
        <li>
          On its own as a [=property=] value in a [=@do patch=], [=@do update=] or similar [=action=] that updates a [=chunk=] to unset a [=property=].
          <aside class="example" title="Unset a chunk property">
            <pre><code># Given the following chunk in the module buffer
basket { fruit apple, banana, orange }

# ... the following rule drops the fruit property
* {} => basket { @do update; fruit ! }

# Resulting chunk
basket {}</code></pre>
          </aside>
        </li>
      </ul>

      <p>The [=negation operator=] cannot be prepended to a [=variable=] that has not yet been [=bound=]. Similarly, the [=negation operator=] cannot be used on its own as an [=atomic value=] in a list. More generally, the [=negation operator=] cannot be used elsewhere than in the cases detailed above.</p>
      <aside class="example" title="Some invalid uses of the negation operator">
        <pre><code># Invalid: variable ?num1 is unbound
count { state counting; start !?num1 } => ...

# Invalid: on its own in a list
basket { fruit ?a, !, ?o } => ...

# Invalid: in an update action but not on its own
* {} => basket { @do update; fruit !apple }</code></pre>
      </aside>

      <p>A second [=negation operator=] prepended to a [=name=] that starts with a [=negation operator=] cancels the effect of the first [=negation operator=].</p>
      <aside class="example" title="Double negation">
        <pre><code># The following condition
person { @id !!John }

# ... is the same as this one:
person { @id John }</code></pre>
      </aside>
    </section>

    <section>
      <h3>The reserved name operator <code>@</code></h3>
      <p>The <dfn>reserved name operator</dfn> <code>@</code> may be prepended to a [=name=] to denote a <dfn>reserved name</dfn> with specific meaning (defined in this specification). Such [=names=] may only appear as [=property=] names.</p>
      <p>[=Reserved names=] control the behavior of [=conditions=] and [=actions=].</p>

      <section>
        <h4>@-properties for conditions and actions</h4>
        <p>The [=reserved names=] defined in this section may be used in [=conditions=] and [=actions=] to control their behavior.</p>

        <section>
          <h5>The <dfn><code>@context</code></dfn> property</h5>
          <p>When used in a regular [=chunk=], identifies a chunk's [=context=]. When used in a [=condition=] or in an [=action=], [=matches=] a [=chunk=]'s [=context=].</p>
          <aside class="example" title="Looks for a chunk in a given context">
            <pre><code>recall { lunch ?restaurant }
     => lookup { @module facts; @do get; @type lunch; @context ?restaurant }</code></pre>
            <p>The above [=rule=] defines an [=action=] that looks for a [=chunk=] in the <code>facts</code> [=module=] whose [=type=] is <code>lunch</code> and whose [=context=] is the identifier of the lunch matched by the <code>recall</code> [=condition=].</p>
          </aside>
        </section>

        <section>
          <h5>The <dfn><code>@do</code></dfn> property</h5>
          <p>Specifies the graph algorithm or operation to execute. See <a href="#built-in-operations"></a> for a list of common operations that are supported across modules.</p>
        </section>

        <section>
          <h5>The <dfn><code>@for</code></dfn> property</h5>
          <p>Iterates over a set of items in a comma separated list. The [=@from=] and [=@to=] properties may be used to restrict the iteration range.</p>
        </section>

        <section>
          <h5>The <dfn><code>@from</code></dfn> property</h5>
          <p>Specifies the zero-based starting index of an [=@for=] iteration. Value must be an integer.</p>
        </section>

        <section>
          <h5>The <dfn><code>@id</code></dfn> property</h5>
          <p>[=Matches=] a [=chunk=]'s [=identifier=], or binds a variable to the [=chunk=]'s [=identifier=].</p>
        </section>

        <section>
          <h5>The <dfn><code>@kindof</code></dfn> property</h5>
          <p>[=Matches=] a [=chunk=]'s [=type=] when that [=type=] is linked to the value of the [=@kindof=] property through a chain of <code>kindof</code> links. The property should be used in conjunction with a <code>*</code> type to match subclasses of a given class in a taxonomy.</p>
          <aside class="example" title="Matching subclasses in a taxonomy">
            <p>Given the following facts in a <code>facts</code> [=module=]:</p>
            <pre><code>penguin kindof bird
eagle kindof bird
penguin p6 { name Pingou }</code></pre>

            <p>The following [=condition=] would match the [=chunk=] <code>p6</code> if it was in the [=module buffer=] of the <code>facts</code> [=module=]:</p>
            <pre><code>* cond1 {
  @module facts
  @kindof bird
}</code></pre>
          </aside>
        </section>

        <section>
          <h5>The <dfn><code>@module</code></dfn> property</h5>
          <p>References the [=module=] a [=condition=] or [=action=] relates to. Value must be the [=module name=] of the targeted [=module=]. In the absence of an [=@module=] property, [=conditions=] and [=actions=] apply to the <code>goal</code> module.</p>
        </section>

        <section>
          <h5>The <dfn><code>@more</code></dfn> property</h5>
          <p>Queries the [=boolean=] flag set to <code>true</code> by the [=rule engine=] on the current [=chunk=] in [=@for=] and [=@do properties=] iterations when there are remaining [=chunks=] to iterate over.</p>
        </section>

        <section>
          <h5>The <dfn><code>@pop</code></dfn> property</h5>
          <p>An [=action=] property that removes the last [=atomic value=] from a [=value=]. If the [=value=] to process is already an [=atomic value=], the underlying property is removed.</p>
          <p>If a [=@to=] property is also present, the removed [=atomic value=] is assigned to the [=property=] identified by the [=@to=] property. In the absence of a [=@to=] property, the removed [=atomic value=] is discarded.</p>
          <aside class="example" title="Remove the last element from a list">
            <p>Given the following [=chunk=] and [=action=]:</p>
            <pre><code>digits { list 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }
digits { @pop list, @to item }</code></pre>
            <p>The [=action=] will update the [=chunk=] to:</p>
            <pre><code>digits {
  list 0, 1, 2, 3, 4, 5, 6, 7, 8
  item 9
}</code></pre>
          </aside>
        </section>

        <section>
          <h5>The <dfn><code>@push</code></dfn> property</h5>
          <p>An [=action=] property that pushes an [=atomic value=] to the end of the [=value=] of the property identified by a companion [=@to=] property. If the targeted property does not exist yet, it is created.</p>
          <p>In the absence of a [=@to=] property, this operation has no effect.</p>
          <aside class="example" title="Add an element to the end of a list">
            <p>Given the following [=chunk=] and [=action=]:</p>
            <pre><code>digits { list 0, 1, 2, 3, 4, 5, 6, 7, 8 }
digits { @push 9, @to list }</code></pre>
            <p>The [=action=] will update the [=chunk=] to:</p>
            <pre><code>digits { list 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }</code></pre>
          </aside>
        </section>

        <section>
          <h5>The <dfn><code>@shift</code></dfn> property</h5>
          <p>An [=action=] property that removes the first [=atomic value=] from a [=value=]. If the [=value=] to process is already an [=atomic value=], the underlying property is removed.</p>
          <p>If a [=@to=] property is also present, the removed [=atomic value=] is assigned to the [=property=] identified by the [=@to=] property. In the absence of a [=@to=] property, the removed [=atomic value=] is discarded.</p>
          <aside class="example" title="Remove the first element from a list">
            <p>Given the following [=chunk=] and [=action=]:</p>
            <pre><code>digits { list 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }
digits { @shift list, @to item }</code></pre>
            <p>The [=action=] will update the [=chunk=] to:</p>
            <pre><code>digits {
  list 1, 2, 3, 4, 5, 6, 7, 8, 9
  item 0
}</code></pre>
          </aside>
        </section>

        <section>
          <h5>The <dfn><code>@status</code></dfn> property</h5>
          <p>Queries the [=module buffer/status=] of a [=module buffer=]. The [=rule engine=] sets the status of a [=module buffer=] with the outcome of the [=rule=]'s execution. Most operations are asynchronous, except [=@do clear=], [=@do update=] and [=@do queue=].</p>
        </section>

        <section>
          <h5>The <dfn><code>@to</code></dfn> property</h5>
          <p>Companion [=action=] property used in [=@do properties=], [=@for=], [=@pop=], [=@push=], [=@shift=], [=@unshift=] operations.</p>
          <p>Meaning and value constraints depend on the operation. See individual operations for details. For instance, when used in a [=@for=] operation, the property specifies the zero-based ending index of the iteration. Value must be an integer. When used in a [=@do properties=] operation, the property specifies the name of the [=module buffer=] onto which to write the current [=chunk=].</p>
        </section>

        <section>
          <h5>The <dfn><code>@type</code></dfn> property</h5>
          <p>[=Matches=] a [=chunk=]'s [=type=], or binds a variable to the [=chunk=]'s [=type=].</p>
        </section>

        <section>
          <h5>The <dfn><code>@unshift</code></dfn> property</h5>
          <p>An [=action=] property that pushes an [=atomic value=] to the beginning of the [=value=] of the property identified by a companion [=@to=] property. If the targeted property does not exist yet, it is created.</p>
          <p>In the absence of a [=@to=] property, this operation has no effect.</p>
          <aside class="example" title="Add an element to the beginning of a list">
            <p>Given the following [=chunk=] and [=action=]:</p>
            <pre><code>digits { list 1, 2, 3, 4, 5, 6, 7, 8 }
digits { @shift 0, @to list }</code></pre>
            <p>The [=action=] will update the [=chunk=] to:</p>
            <pre><code>digits { list 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }</code></pre>
          </aside>
        </section>

        <p class="ednote">TODO: Complete list with additional reserved names: <code>@undefined</code>, <code>@unique</code>, <code>@compile</code>, <code>@index</code>, <code>@map</code>, <code>@priority</code>, <code>@source</code>, <code>@tag</code>, <code>@uncompile</code>, <code>@undefine</code>.</p>
      </section>
    </section>
  </section>

  <section>
    <h2>Rule engine execution</h2>
    <p class="ednote">TODO: Describe algorithms for the [=rule engine=].</p>
  </section>

  <section>
    <h2>Chunks documents</h2>

    <section>
      <h3>Parsing a chunks document</h3>
      <p class="ednote">TODO: Formally describe parsing algorithm</p>
      <p>If multiple chunk definitions share the same [=identifier=] in a set of chunks, the last definition overrides former definitions.</p>
    </section>

    <section>
      <h3>Chunks grammar</h3>
      <p>A [=chunks document=] MUST follow the grammar defined below.</p>

<pre><code class="abnf" data-include="grammar/chunks.abnf" data-include-format="text"></code></pre>
    </section>

    <section class="informative">
      <h3>Railroad diagrams</h3>
      <p>This section presents an informative view of the tokens that the grammar defines, in the form of railroad diagrams. These diagrams are provided solely to make it easier to get an intuitive grasp of the syntax of each token.</p>
      <div data-include="grammar/rr.html" data-include-replace="true"></div>
    </section>
  </section>

  <section>
    <h2>Mapping to RDF</h2>
    <p class="ednote">TODO: document <code>@rdfmap</code>, <code>@base</code>, <code>@prefix</code>.</p>
  </section>

  <section id="index" class="appendix">
  </section>
</body>
</html>